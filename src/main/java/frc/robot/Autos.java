package frc.robot;

import java.nio.file.Path;
import java.io.IOException;
import edu.wpi.first.wpilibj.Filesystem;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.controller.ProfiledPIDController;
import edu.wpi.first.math.trajectory.Trajectory;
import edu.wpi.first.math.trajectory.TrajectoryUtil;
import frc.robot.Constants.AutoConstants;
import frc.robot.Constants.DriveConstants;
import frc.robot.subsystems.DriveSubsystem;
import frc.robot.subsystems.Infeed;
import frc.robot.subsystems.Shooter;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.SwerveControllerCommand;
import java.util.List;
import frc.robot.subsystems.ShoulderSubsystem;
import frc.robot.Constants.ShoulderConstants;
import com.pathplanner.lib.commands.PathPlannerAuto;
import com.pathplanner.lib.auto.AutoBuilder;




public class Autos {

    private final DriveSubsystem m_robotDrive;
    private final Infeed m_Infeed;
    private final ShoulderSubsystem m_ShoulderSubsystem;
    private final Shooter m_Shooter;

    public Autos(DriveSubsystem inDriveSubsystem, Infeed inInfeedSubsystem, ShoulderSubsystem inShoulderSubsystem, Shooter inShooter){
        m_robotDrive = inDriveSubsystem;
        m_Infeed = inInfeedSubsystem;
        m_ShoulderSubsystem = inShoulderSubsystem;
        m_Shooter = inShooter;

        
    }


    /**
   * Generates an executable command from a PathPlanner json file. 
   * @param filename String file path from the deploy folder. For pathplanner: "pathplanner/generatedJSON/ExamplePath.wpilib.json"
   * @return a {@link SwerveControllerCommand} to run in the autonomousInit() command.
   */
    public Command getPathPlannerAuto(String filename) {
    
        Trajectory trajectory;
    
        try {
          Path trajectoryPath = Filesystem.getDeployDirectory().toPath().resolve(filename);
          trajectory = TrajectoryUtil.fromPathweaverJson(trajectoryPath);
        } catch (IOException exception) {
          DriverStation.reportError("Unable to open trajectory "  + filename, exception.getStackTrace());
          System.out.println("Unable to read from file " + filename);
          return new InstantCommand();
        }
    
        var thetaController = new ProfiledPIDController(
            AutoConstants.kPThetaController, 0, 0, AutoConstants.kThetaControllerConstraints);
        thetaController.enableContinuousInput(-Math.PI, Math.PI);
    
        SwerveControllerCommand swerveControllerCommand = new SwerveControllerCommand(
          trajectory,
            m_robotDrive::getPose, // Functional interface to feed supplier
            DriveConstants.kDriveKinematics,
    
            // Position controllers
            new PIDController(AutoConstants.kPXController, 0, 0),
            new PIDController(AutoConstants.kPYController, 0, 0),
            thetaController,
            m_robotDrive::setModuleStates,
            m_robotDrive);
    
        // Reset odometry to the starting pose of the trajectory.
        m_robotDrive.resetOdometry(trajectory.getInitialPose());
    
        // Run path following command, then stop at the end.
        return swerveControllerCommand;
      }

    /*
     * This is the newly updated pathplanner function for version 2024.
     * filePath is the name of .auto file that was generated by the pathplanner gui
     */
    public Command makePathPlannerAuto(String filePath){
      return new PathPlannerAuto(filePath);
    }

    public List<String> getAutoNames(){
      return AutoBuilder.getAllAutoNames();
    }
}
